// This file is auto-generated by @hey-api/openapi-ts

/**
 * Application model
 */
export type Application = {
  /**
   * The application identifier in the database.
   */
  id?: number
  /**
   * The application description.
   */
  description?: string
  /**
   * The repository project identifier.
   */
  repository_project_id?: number
  /**
   * The application UUID.
   */
  uuid?: string
  /**
   * The application name.
   */
  name?: string
  /**
   * The application domains.
   */
  fqdn?: string
  /**
   * Configuration hash.
   */
  config_hash?: string
  /**
   * Git repository URL.
   */
  git_repository?: string
  /**
   * Git branch.
   */
  git_branch?: string
  /**
   * Git commit SHA.
   */
  git_commit_sha?: string
  /**
   * Git full URL.
   */
  git_full_url?: string
  /**
   * Docker registry image name.
   */
  docker_registry_image_name?: string
  /**
   * Docker registry image tag.
   */
  docker_registry_image_tag?: string
  /**
   * Build pack.
   */
  build_pack?: 'nixpacks' | 'static' | 'dockerfile' | 'dockercompose'
  /**
   * Static image used when static site is deployed.
   */
  static_image?: string
  /**
   * Install command.
   */
  install_command?: string
  /**
   * Build command.
   */
  build_command?: string
  /**
   * Start command.
   */
  start_command?: string
  /**
   * Ports exposes.
   */
  ports_exposes?: string
  /**
   * Ports mappings.
   */
  ports_mappings?: string
  /**
   * Network aliases for Docker container.
   */
  custom_network_aliases?: string
  /**
   * Base directory for all commands.
   */
  base_directory?: string
  /**
   * Publish directory.
   */
  publish_directory?: string
  /**
   * Health check enabled.
   */
  health_check_enabled?: boolean
  /**
   * Health check path.
   */
  health_check_path?: string
  /**
   * Health check port.
   */
  health_check_port?: string
  /**
   * Health check host.
   */
  health_check_host?: string
  /**
   * Health check method.
   */
  health_check_method?: string
  /**
   * Health check return code.
   */
  health_check_return_code?: number
  /**
   * Health check scheme.
   */
  health_check_scheme?: string
  /**
   * Health check response text.
   */
  health_check_response_text?: string
  /**
   * Health check interval in seconds.
   */
  health_check_interval?: number
  /**
   * Health check timeout in seconds.
   */
  health_check_timeout?: number
  /**
   * Health check retries count.
   */
  health_check_retries?: number
  /**
   * Health check start period in seconds.
   */
  health_check_start_period?: number
  /**
   * Memory limit.
   */
  limits_memory?: string
  /**
   * Memory swap limit.
   */
  limits_memory_swap?: string
  /**
   * Memory swappiness.
   */
  limits_memory_swappiness?: number
  /**
   * Memory reservation.
   */
  limits_memory_reservation?: string
  /**
   * CPU limit.
   */
  limits_cpus?: string
  /**
   * CPU set.
   */
  limits_cpuset?: string
  /**
   * CPU shares.
   */
  limits_cpu_shares?: number
  /**
   * Application status.
   */
  status?: string
  /**
   * Preview URL template.
   */
  preview_url_template?: string
  /**
   * Destination type.
   */
  destination_type?: string
  /**
   * Destination identifier.
   */
  destination_id?: number
  /**
   * Source identifier.
   */
  source_id?: number
  /**
   * Private key identifier.
   */
  private_key_id?: number
  /**
   * Environment identifier.
   */
  environment_id?: number
  /**
   * Dockerfile content. Used for dockerfile build pack.
   */
  dockerfile?: string
  /**
   * Dockerfile location.
   */
  dockerfile_location?: string
  /**
   * Custom labels.
   */
  custom_labels?: string
  /**
   * Dockerfile target build.
   */
  dockerfile_target_build?: string
  /**
   * Manual webhook secret for GitHub.
   */
  manual_webhook_secret_github?: string
  /**
   * Manual webhook secret for GitLab.
   */
  manual_webhook_secret_gitlab?: string
  /**
   * Manual webhook secret for Bitbucket.
   */
  manual_webhook_secret_bitbucket?: string
  /**
   * Manual webhook secret for Gitea.
   */
  manual_webhook_secret_gitea?: string
  /**
   * Docker compose location.
   */
  docker_compose_location?: string
  /**
   * Docker compose content. Used for docker compose build pack.
   */
  docker_compose?: string
  /**
   * Docker compose raw content.
   */
  docker_compose_raw?: string
  /**
   * Docker compose domains.
   */
  docker_compose_domains?: string
  /**
   * Docker compose custom start command.
   */
  docker_compose_custom_start_command?: string
  /**
   * Docker compose custom build command.
   */
  docker_compose_custom_build_command?: string
  /**
   * Swarm replicas. Only used for swarm deployments.
   */
  swarm_replicas?: number
  /**
   * Swarm placement constraints. Only used for swarm deployments.
   */
  swarm_placement_constraints?: string
  /**
   * Custom docker run options.
   */
  custom_docker_run_options?: string
  /**
   * Post deployment command.
   */
  post_deployment_command?: string
  /**
   * Post deployment command container.
   */
  post_deployment_command_container?: string
  /**
   * Pre deployment command.
   */
  pre_deployment_command?: string
  /**
   * Pre deployment command container.
   */
  pre_deployment_command_container?: string
  /**
   * Watch paths.
   */
  watch_paths?: string
  /**
   * Custom healthcheck found.
   */
  custom_healthcheck_found?: boolean
  /**
   * How to set redirect with Traefik / Caddy. www<->non-www.
   */
  redirect?: 'www' | 'non-www' | 'both'
  /**
   * The date and time when the application was created.
   */
  created_at?: string
  /**
   * The date and time when the application was last updated.
   */
  updated_at?: string
  /**
   * The date and time when the application was deleted.
   */
  deleted_at?: string
  /**
   * How Coolify parse the compose file.
   */
  compose_parsing_version?: string
  /**
   * Custom Nginx configuration base64 encoded.
   */
  custom_nginx_configuration?: string
  /**
   * HTTP Basic Authentication enabled.
   */
  is_http_basic_auth_enabled?: boolean
  /**
   * Username for HTTP Basic Authentication
   */
  http_basic_auth_username?: string
  /**
   * Password for HTTP Basic Authentication
   */
  http_basic_auth_password?: string
}

/**
 * Project model
 */
export type ApplicationDeploymentQueue = {
  id?: number
  application_id?: string
  deployment_uuid?: string
  pull_request_id?: number
  force_rebuild?: boolean
  commit?: string
  status?: string
  is_webhook?: boolean
  is_api?: boolean
  created_at?: string
  updated_at?: string
  logs?: string
  current_process_id?: string
  restart_only?: boolean
  git_type?: string
  server_id?: number
  application_name?: string
  server_name?: string
  deployment_url?: string
  destination_id?: string
  only_this_server?: boolean
  rollback?: boolean
  commit_message?: string
}

/**
 * Environment model
 */
export type Environment = {
  id?: number
  name?: string
  project_id?: number
  created_at?: string
  updated_at?: string
  description?: string
  applications?: Application[]
  services?: Service[]
}

/**
 * Environment Variable model
 */
export type EnvironmentVariable = {
  id?: number
  uuid?: string
  resourceable_type?: string
  resourceable_id?: number
  is_build_time?: boolean
  is_literal?: boolean
  is_multiline?: boolean
  is_preview?: boolean
  is_shared?: boolean
  is_shown_once?: boolean
  key?: string
  value?: string
  real_value?: string
  version?: string
  created_at?: string
  updated_at?: string
}

/**
 * Private Key model
 */
export type PrivateKey = {
  id?: number
  uuid?: string
  name?: string
  description?: string
  private_key?: string
  /**
   * The public key of the private key.
   */
  public_key?: string
  /**
   * The fingerprint of the private key.
   */
  fingerprint?: string
  is_git_related?: boolean
  team_id?: number
  created_at?: string
  updated_at?: string
}

/**
 * Project model
 */
export type Project = {
  id?: number
  uuid?: string
  name?: string
  description?: string
  /**
   * The environments of the project.
   */
  environments?: Array<Environment>
}

/**
 * Server model
 */
export type Server = {
  /**
   * The server ID.
   */
  id?: number
  /**
   * The server UUID.
   */
  uuid?: string
  /**
   * The server name.
   */
  name?: string
  /**
   * The server description.
   */
  description?: string
  /**
   * The IP address.
   */
  ip?: string
  /**
   * The user.
   */
  user?: string
  /**
   * The port number.
   */
  port?: number
  /**
   * The proxy configuration.
   */
  proxy?: {
    [key: string]: unknown
  }
  /**
   * The proxy type.
   */
  proxy_type?: 'traefik' | 'caddy' | 'none'
  /**
   * The flag to indicate if the high disk usage notification has been sent.
   */
  high_disk_usage_notification_sent?: boolean
  /**
   * The flag to indicate if the unreachable notification has been sent.
   */
  unreachable_notification_sent?: boolean
  /**
   * The unreachable count for your server.
   */
  unreachable_count?: number
  /**
   * The validation logs.
   */
  validation_logs?: string
  /**
   * The flag to indicate if the log drain notification has been sent.
   */
  log_drain_notification_sent?: boolean
  /**
   * The swarm cluster configuration.
   */
  swarm_cluster?: string
  settings?: ServerSetting
}

/**
 * Server Settings model
 */
export type ServerSetting = {
  id?: number
  concurrent_builds?: number
  dynamic_timeout?: number
  force_disabled?: boolean
  force_server_cleanup?: boolean
  is_build_server?: boolean
  is_cloudflare_tunnel?: boolean
  is_jump_server?: boolean
  is_logdrain_axiom_enabled?: boolean
  is_logdrain_custom_enabled?: boolean
  is_logdrain_highlight_enabled?: boolean
  is_logdrain_newrelic_enabled?: boolean
  is_metrics_enabled?: boolean
  is_reachable?: boolean
  is_sentinel_enabled?: boolean
  is_swarm_manager?: boolean
  is_swarm_worker?: boolean
  is_usable?: boolean
  logdrain_axiom_api_key?: string
  logdrain_axiom_dataset_name?: string
  logdrain_custom_config?: string
  logdrain_custom_config_parser?: string
  logdrain_highlight_project_id?: string
  logdrain_newrelic_base_uri?: string
  logdrain_newrelic_license_key?: string
  sentinel_metrics_history_days?: number
  sentinel_metrics_refresh_rate_seconds?: number
  sentinel_token?: string
  docker_cleanup_frequency?: string
  docker_cleanup_threshold?: number
  server_id?: number
  wildcard_domain?: string
  created_at?: string
  updated_at?: string
  /**
   * The flag to indicate if the unused volumes should be deleted.
   */
  delete_unused_volumes?: boolean
  /**
   * The flag to indicate if the unused networks should be deleted.
   */
  delete_unused_networks?: boolean
}

/**
 * Service model
 */
export type Service = {
  /**
   * The unique identifier of the service. Only used for database identification.
   */
  id?: number
  /**
   * The unique identifier of the service.
   */
  uuid?: string
  /**
   * The name of the service.
   */
  name?: string
  /**
   * The unique identifier of the environment where the service is attached to.
   */
  environment_id?: number
  /**
   * The unique identifier of the server where the service is running.
   */
  server_id?: number
  /**
   * The description of the service.
   */
  description?: string
  /**
   * The raw docker-compose.yml file of the service.
   */
  docker_compose_raw?: string
  /**
   * The docker-compose.yml file that is parsed and modified by Coolify.
   */
  docker_compose?: string
  /**
   * Destination type.
   */
  destination_type?: string
  /**
   * The unique identifier of the destination where the service is running.
   */
  destination_id?: number
  /**
   * The flag to connect the service to the predefined Docker network.
   */
  connect_to_docker_network?: boolean
  /**
   * The flag to enable the container label escape.
   */
  is_container_label_escape_enabled?: boolean
  /**
   * The flag to enable the container label readonly.
   */
  is_container_label_readonly_enabled?: boolean
  /**
   * The hash of the service configuration.
   */
  config_hash?: string
  /**
   * The type of the service.
   */
  service_type?: string
  /**
   * The date and time when the service was created.
   */
  created_at?: string
  /**
   * The date and time when the service was last updated.
   */
  updated_at?: string
  /**
   * The date and time when the service was deleted.
   */
  deleted_at?: string
}

/**
 * Team model
 */
export type Team = {
  /**
   * The unique identifier of the team.
   */
  id?: number
  /**
   * The name of the team.
   */
  name?: string
  /**
   * The description of the team.
   */
  description?: string
  /**
   * Whether the team is personal or not.
   */
  personal_team?: boolean
  /**
   * The date and time the team was created.
   */
  created_at?: string
  /**
   * The date and time the team was last updated.
   */
  updated_at?: string
  /**
   * Whether to show the boarding screen or not.
   */
  show_boarding?: boolean
  /**
   * The custom server limit.
   */
  custom_server_limit?: string
  /**
   * The members of the team.
   */
  members?: Array<User>
}

/**
 * User model
 */
export type User = {
  /**
   * The user identifier in the database.
   */
  id?: number
  /**
   * The user name.
   */
  name?: string
  /**
   * The user email.
   */
  email?: string
  /**
   * The date when the user email was verified.
   */
  email_verified_at?: string
  /**
   * The date when the user was created.
   */
  created_at?: string
  /**
   * The date when the user was updated.
   */
  updated_at?: string
  /**
   * The date when the user two factor was confirmed.
   */
  two_factor_confirmed_at?: string
  /**
   * The flag to force the user to reset the password.
   */
  force_password_reset?: boolean
  /**
   * The flag to receive marketing emails.
   */
  marketing_emails?: boolean
}

export type ListApplicationsData = {
  body?: never
  path?: never
  query?: never
  url: '/applications'
}

export type ListApplicationsErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListApplicationsError =
  ListApplicationsErrors[keyof ListApplicationsErrors]

export type ListApplicationsResponses = {
  /**
   * Get all applications.
   */
  200: Array<Application>
}

export type ListApplicationsResponse =
  ListApplicationsResponses[keyof ListApplicationsResponses]

export type CreatePublicApplicationData = {
  /**
   * Application object that needs to be created.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * The environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * The git repository URL.
     */
    git_repository: string
    /**
     * The git branch.
     */
    git_branch: string
    /**
     * The build pack type.
     */
    build_pack: 'nixpacks' | 'static' | 'dockerfile' | 'dockercompose'
    /**
     * The ports to expose.
     */
    ports_exposes: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The application domains.
     */
    domains?: string
    /**
     * The git commit SHA.
     */
    git_commit_sha?: string
    /**
     * The docker registry image name.
     */
    docker_registry_image_name?: string
    /**
     * The docker registry image tag.
     */
    docker_registry_image_tag?: string
    /**
     * The flag to indicate if the application is static.
     */
    is_static?: boolean
    /**
     * The static image.
     */
    static_image?: 'nginx:alpine'
    /**
     * The install command.
     */
    install_command?: string
    /**
     * The build command.
     */
    build_command?: string
    /**
     * The start command.
     */
    start_command?: string
    /**
     * The ports mappings.
     */
    ports_mappings?: string
    /**
     * The base directory for all commands.
     */
    base_directory?: string
    /**
     * The publish directory.
     */
    publish_directory?: string
    /**
     * Health check enabled.
     */
    health_check_enabled?: boolean
    /**
     * Health check path.
     */
    health_check_path?: string
    /**
     * Health check port.
     */
    health_check_port?: string
    /**
     * Health check host.
     */
    health_check_host?: string
    /**
     * Health check method.
     */
    health_check_method?: string
    /**
     * Health check return code.
     */
    health_check_return_code?: number
    /**
     * Health check scheme.
     */
    health_check_scheme?: string
    /**
     * Health check response text.
     */
    health_check_response_text?: string
    /**
     * Health check interval in seconds.
     */
    health_check_interval?: number
    /**
     * Health check timeout in seconds.
     */
    health_check_timeout?: number
    /**
     * Health check retries count.
     */
    health_check_retries?: number
    /**
     * Health check start period in seconds.
     */
    health_check_start_period?: number
    /**
     * Memory limit.
     */
    limits_memory?: string
    /**
     * Memory swap limit.
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness.
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation.
     */
    limits_memory_reservation?: string
    /**
     * CPU limit.
     */
    limits_cpus?: string
    /**
     * CPU set.
     */
    limits_cpuset?: string
    /**
     * CPU shares.
     */
    limits_cpu_shares?: number
    /**
     * Custom labels.
     */
    custom_labels?: string
    /**
     * Custom docker run options.
     */
    custom_docker_run_options?: string
    /**
     * Post deployment command.
     */
    post_deployment_command?: string
    /**
     * Post deployment command container.
     */
    post_deployment_command_container?: string
    /**
     * Pre deployment command.
     */
    pre_deployment_command?: string
    /**
     * Pre deployment command container.
     */
    pre_deployment_command_container?: string
    /**
     * Manual webhook secret for Github.
     */
    manual_webhook_secret_github?: string
    /**
     * Manual webhook secret for Gitlab.
     */
    manual_webhook_secret_gitlab?: string
    /**
     * Manual webhook secret for Bitbucket.
     */
    manual_webhook_secret_bitbucket?: string
    /**
     * Manual webhook secret for Gitea.
     */
    manual_webhook_secret_gitea?: string
    /**
     * How to set redirect with Traefik / Caddy. www<->non-www.
     */
    redirect?: 'www' | 'non-www' | 'both'
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * The Dockerfile content.
     */
    dockerfile?: string
    /**
     * The Docker Compose location.
     */
    docker_compose_location?: string
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw?: string
    /**
     * The Docker Compose custom start command.
     */
    docker_compose_custom_start_command?: string
    /**
     * The Docker Compose custom build command.
     */
    docker_compose_custom_build_command?: string
    /**
     * The Docker Compose domains.
     */
    docker_compose_domains?: Array<unknown>
    /**
     * The watch paths.
     */
    watch_paths?: string
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * HTTP Basic Authentication enabled.
     */
    is_http_basic_auth_enabled?: boolean
    /**
     * Username for HTTP Basic Authentication
     */
    http_basic_auth_username?: string
    /**
     * Password for HTTP Basic Authentication
     */
    http_basic_auth_password?: string
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path?: never
  query?: never
  url: '/applications/public'
}

export type CreatePublicApplicationErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreatePublicApplicationError =
  CreatePublicApplicationErrors[keyof CreatePublicApplicationErrors]

export type CreatePublicApplicationResponses = {
  /**
   * Application created successfully.
   */
  201: {
    uuid?: string
  }
}

export type CreatePublicApplicationResponse =
  CreatePublicApplicationResponses[keyof CreatePublicApplicationResponses]

export type CreatePrivateGithubAppApplicationData = {
  /**
   * Application object that needs to be created.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * The environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * The Github App UUID.
     */
    github_app_uuid: string
    /**
     * The git repository URL.
     */
    git_repository: string
    /**
     * The git branch.
     */
    git_branch: string
    /**
     * The ports to expose.
     */
    ports_exposes: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The build pack type.
     */
    build_pack: 'nixpacks' | 'static' | 'dockerfile' | 'dockercompose'
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The application domains.
     */
    domains?: string
    /**
     * The git commit SHA.
     */
    git_commit_sha?: string
    /**
     * The docker registry image name.
     */
    docker_registry_image_name?: string
    /**
     * The docker registry image tag.
     */
    docker_registry_image_tag?: string
    /**
     * The flag to indicate if the application is static.
     */
    is_static?: boolean
    /**
     * The static image.
     */
    static_image?: 'nginx:alpine'
    /**
     * The install command.
     */
    install_command?: string
    /**
     * The build command.
     */
    build_command?: string
    /**
     * The start command.
     */
    start_command?: string
    /**
     * The ports mappings.
     */
    ports_mappings?: string
    /**
     * The base directory for all commands.
     */
    base_directory?: string
    /**
     * The publish directory.
     */
    publish_directory?: string
    /**
     * Health check enabled.
     */
    health_check_enabled?: boolean
    /**
     * Health check path.
     */
    health_check_path?: string
    /**
     * Health check port.
     */
    health_check_port?: string
    /**
     * Health check host.
     */
    health_check_host?: string
    /**
     * Health check method.
     */
    health_check_method?: string
    /**
     * Health check return code.
     */
    health_check_return_code?: number
    /**
     * Health check scheme.
     */
    health_check_scheme?: string
    /**
     * Health check response text.
     */
    health_check_response_text?: string
    /**
     * Health check interval in seconds.
     */
    health_check_interval?: number
    /**
     * Health check timeout in seconds.
     */
    health_check_timeout?: number
    /**
     * Health check retries count.
     */
    health_check_retries?: number
    /**
     * Health check start period in seconds.
     */
    health_check_start_period?: number
    /**
     * Memory limit.
     */
    limits_memory?: string
    /**
     * Memory swap limit.
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness.
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation.
     */
    limits_memory_reservation?: string
    /**
     * CPU limit.
     */
    limits_cpus?: string
    /**
     * CPU set.
     */
    limits_cpuset?: string
    /**
     * CPU shares.
     */
    limits_cpu_shares?: number
    /**
     * Custom labels.
     */
    custom_labels?: string
    /**
     * Custom docker run options.
     */
    custom_docker_run_options?: string
    /**
     * Post deployment command.
     */
    post_deployment_command?: string
    /**
     * Post deployment command container.
     */
    post_deployment_command_container?: string
    /**
     * Pre deployment command.
     */
    pre_deployment_command?: string
    /**
     * Pre deployment command container.
     */
    pre_deployment_command_container?: string
    /**
     * Manual webhook secret for Github.
     */
    manual_webhook_secret_github?: string
    /**
     * Manual webhook secret for Gitlab.
     */
    manual_webhook_secret_gitlab?: string
    /**
     * Manual webhook secret for Bitbucket.
     */
    manual_webhook_secret_bitbucket?: string
    /**
     * Manual webhook secret for Gitea.
     */
    manual_webhook_secret_gitea?: string
    /**
     * How to set redirect with Traefik / Caddy. www<->non-www.
     */
    redirect?: 'www' | 'non-www' | 'both'
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * The Dockerfile content.
     */
    dockerfile?: string
    /**
     * The Docker Compose location.
     */
    docker_compose_location?: string
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw?: string
    /**
     * The Docker Compose custom start command.
     */
    docker_compose_custom_start_command?: string
    /**
     * The Docker Compose custom build command.
     */
    docker_compose_custom_build_command?: string
    /**
     * The Docker Compose domains.
     */
    docker_compose_domains?: Array<unknown>
    /**
     * The watch paths.
     */
    watch_paths?: string
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * HTTP Basic Authentication enabled.
     */
    is_http_basic_auth_enabled?: boolean
    /**
     * Username for HTTP Basic Authentication
     */
    http_basic_auth_username?: string
    /**
     * Password for HTTP Basic Authentication
     */
    http_basic_auth_password?: string
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path?: never
  query?: never
  url: '/applications/private-github-app'
}

export type CreatePrivateGithubAppApplicationErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreatePrivateGithubAppApplicationError =
  CreatePrivateGithubAppApplicationErrors[keyof CreatePrivateGithubAppApplicationErrors]

export type CreatePrivateGithubAppApplicationResponses = {
  /**
   * Application created successfully.
   */
  201: {
    uuid?: string
  }
}

export type CreatePrivateGithubAppApplicationResponse =
  CreatePrivateGithubAppApplicationResponses[keyof CreatePrivateGithubAppApplicationResponses]

export type CreatePrivateDeployKeyApplicationData = {
  /**
   * Application object that needs to be created.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * The environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * The private key UUID.
     */
    private_key_uuid: string
    /**
     * The git repository URL.
     */
    git_repository: string
    /**
     * The git branch.
     */
    git_branch: string
    /**
     * The ports to expose.
     */
    ports_exposes: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The build pack type.
     */
    build_pack: 'nixpacks' | 'static' | 'dockerfile' | 'dockercompose'
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The application domains.
     */
    domains?: string
    /**
     * The git commit SHA.
     */
    git_commit_sha?: string
    /**
     * The docker registry image name.
     */
    docker_registry_image_name?: string
    /**
     * The docker registry image tag.
     */
    docker_registry_image_tag?: string
    /**
     * The flag to indicate if the application is static.
     */
    is_static?: boolean
    /**
     * The static image.
     */
    static_image?: 'nginx:alpine'
    /**
     * The install command.
     */
    install_command?: string
    /**
     * The build command.
     */
    build_command?: string
    /**
     * The start command.
     */
    start_command?: string
    /**
     * The ports mappings.
     */
    ports_mappings?: string
    /**
     * The base directory for all commands.
     */
    base_directory?: string
    /**
     * The publish directory.
     */
    publish_directory?: string
    /**
     * Health check enabled.
     */
    health_check_enabled?: boolean
    /**
     * Health check path.
     */
    health_check_path?: string
    /**
     * Health check port.
     */
    health_check_port?: string
    /**
     * Health check host.
     */
    health_check_host?: string
    /**
     * Health check method.
     */
    health_check_method?: string
    /**
     * Health check return code.
     */
    health_check_return_code?: number
    /**
     * Health check scheme.
     */
    health_check_scheme?: string
    /**
     * Health check response text.
     */
    health_check_response_text?: string
    /**
     * Health check interval in seconds.
     */
    health_check_interval?: number
    /**
     * Health check timeout in seconds.
     */
    health_check_timeout?: number
    /**
     * Health check retries count.
     */
    health_check_retries?: number
    /**
     * Health check start period in seconds.
     */
    health_check_start_period?: number
    /**
     * Memory limit.
     */
    limits_memory?: string
    /**
     * Memory swap limit.
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness.
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation.
     */
    limits_memory_reservation?: string
    /**
     * CPU limit.
     */
    limits_cpus?: string
    /**
     * CPU set.
     */
    limits_cpuset?: string
    /**
     * CPU shares.
     */
    limits_cpu_shares?: number
    /**
     * Custom labels.
     */
    custom_labels?: string
    /**
     * Custom docker run options.
     */
    custom_docker_run_options?: string
    /**
     * Post deployment command.
     */
    post_deployment_command?: string
    /**
     * Post deployment command container.
     */
    post_deployment_command_container?: string
    /**
     * Pre deployment command.
     */
    pre_deployment_command?: string
    /**
     * Pre deployment command container.
     */
    pre_deployment_command_container?: string
    /**
     * Manual webhook secret for Github.
     */
    manual_webhook_secret_github?: string
    /**
     * Manual webhook secret for Gitlab.
     */
    manual_webhook_secret_gitlab?: string
    /**
     * Manual webhook secret for Bitbucket.
     */
    manual_webhook_secret_bitbucket?: string
    /**
     * Manual webhook secret for Gitea.
     */
    manual_webhook_secret_gitea?: string
    /**
     * How to set redirect with Traefik / Caddy. www<->non-www.
     */
    redirect?: 'www' | 'non-www' | 'both'
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * The Dockerfile content.
     */
    dockerfile?: string
    /**
     * The Docker Compose location.
     */
    docker_compose_location?: string
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw?: string
    /**
     * The Docker Compose custom start command.
     */
    docker_compose_custom_start_command?: string
    /**
     * The Docker Compose custom build command.
     */
    docker_compose_custom_build_command?: string
    /**
     * The Docker Compose domains.
     */
    docker_compose_domains?: Array<unknown>
    /**
     * The watch paths.
     */
    watch_paths?: string
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * HTTP Basic Authentication enabled.
     */
    is_http_basic_auth_enabled?: boolean
    /**
     * Username for HTTP Basic Authentication
     */
    http_basic_auth_username?: string
    /**
     * Password for HTTP Basic Authentication
     */
    http_basic_auth_password?: string
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path?: never
  query?: never
  url: '/applications/private-deploy-key'
}

export type CreatePrivateDeployKeyApplicationErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreatePrivateDeployKeyApplicationError =
  CreatePrivateDeployKeyApplicationErrors[keyof CreatePrivateDeployKeyApplicationErrors]

export type CreatePrivateDeployKeyApplicationResponses = {
  /**
   * Application created successfully.
   */
  201: {
    uuid?: string
  }
}

export type CreatePrivateDeployKeyApplicationResponse =
  CreatePrivateDeployKeyApplicationResponses[keyof CreatePrivateDeployKeyApplicationResponses]

export type CreateDockerfileApplicationData = {
  /**
   * Application object that needs to be created.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * The environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * The Dockerfile content.
     */
    dockerfile: string
    /**
     * The build pack type.
     */
    build_pack?: 'nixpacks' | 'static' | 'dockerfile' | 'dockercompose'
    /**
     * The ports to expose.
     */
    ports_exposes?: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The application domains.
     */
    domains?: string
    /**
     * The docker registry image name.
     */
    docker_registry_image_name?: string
    /**
     * The docker registry image tag.
     */
    docker_registry_image_tag?: string
    /**
     * The ports mappings.
     */
    ports_mappings?: string
    /**
     * The base directory for all commands.
     */
    base_directory?: string
    /**
     * Health check enabled.
     */
    health_check_enabled?: boolean
    /**
     * Health check path.
     */
    health_check_path?: string
    /**
     * Health check port.
     */
    health_check_port?: string
    /**
     * Health check host.
     */
    health_check_host?: string
    /**
     * Health check method.
     */
    health_check_method?: string
    /**
     * Health check return code.
     */
    health_check_return_code?: number
    /**
     * Health check scheme.
     */
    health_check_scheme?: string
    /**
     * Health check response text.
     */
    health_check_response_text?: string
    /**
     * Health check interval in seconds.
     */
    health_check_interval?: number
    /**
     * Health check timeout in seconds.
     */
    health_check_timeout?: number
    /**
     * Health check retries count.
     */
    health_check_retries?: number
    /**
     * Health check start period in seconds.
     */
    health_check_start_period?: number
    /**
     * Memory limit.
     */
    limits_memory?: string
    /**
     * Memory swap limit.
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness.
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation.
     */
    limits_memory_reservation?: string
    /**
     * CPU limit.
     */
    limits_cpus?: string
    /**
     * CPU set.
     */
    limits_cpuset?: string
    /**
     * CPU shares.
     */
    limits_cpu_shares?: number
    /**
     * Custom labels.
     */
    custom_labels?: string
    /**
     * Custom docker run options.
     */
    custom_docker_run_options?: string
    /**
     * Post deployment command.
     */
    post_deployment_command?: string
    /**
     * Post deployment command container.
     */
    post_deployment_command_container?: string
    /**
     * Pre deployment command.
     */
    pre_deployment_command?: string
    /**
     * Pre deployment command container.
     */
    pre_deployment_command_container?: string
    /**
     * Manual webhook secret for Github.
     */
    manual_webhook_secret_github?: string
    /**
     * Manual webhook secret for Gitlab.
     */
    manual_webhook_secret_gitlab?: string
    /**
     * Manual webhook secret for Bitbucket.
     */
    manual_webhook_secret_bitbucket?: string
    /**
     * Manual webhook secret for Gitea.
     */
    manual_webhook_secret_gitea?: string
    /**
     * How to set redirect with Traefik / Caddy. www<->non-www.
     */
    redirect?: 'www' | 'non-www' | 'both'
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * HTTP Basic Authentication enabled.
     */
    is_http_basic_auth_enabled?: boolean
    /**
     * Username for HTTP Basic Authentication
     */
    http_basic_auth_username?: string
    /**
     * Password for HTTP Basic Authentication
     */
    http_basic_auth_password?: string
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path?: never
  query?: never
  url: '/applications/dockerfile'
}

export type CreateDockerfileApplicationErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDockerfileApplicationError =
  CreateDockerfileApplicationErrors[keyof CreateDockerfileApplicationErrors]

export type CreateDockerfileApplicationResponses = {
  /**
   * Application created successfully.
   */
  201: {
    uuid?: string
  }
}

export type CreateDockerfileApplicationResponse =
  CreateDockerfileApplicationResponses[keyof CreateDockerfileApplicationResponses]

export type CreateDockerimageApplicationData = {
  /**
   * Application object that needs to be created.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * The environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * The docker registry image name.
     */
    docker_registry_image_name: string
    /**
     * The docker registry image tag.
     */
    docker_registry_image_tag?: string
    /**
     * The ports to expose.
     */
    ports_exposes: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The application domains.
     */
    domains?: string
    /**
     * The ports mappings.
     */
    ports_mappings?: string
    /**
     * Health check enabled.
     */
    health_check_enabled?: boolean
    /**
     * Health check path.
     */
    health_check_path?: string
    /**
     * Health check port.
     */
    health_check_port?: string
    /**
     * Health check host.
     */
    health_check_host?: string
    /**
     * Health check method.
     */
    health_check_method?: string
    /**
     * Health check return code.
     */
    health_check_return_code?: number
    /**
     * Health check scheme.
     */
    health_check_scheme?: string
    /**
     * Health check response text.
     */
    health_check_response_text?: string
    /**
     * Health check interval in seconds.
     */
    health_check_interval?: number
    /**
     * Health check timeout in seconds.
     */
    health_check_timeout?: number
    /**
     * Health check retries count.
     */
    health_check_retries?: number
    /**
     * Health check start period in seconds.
     */
    health_check_start_period?: number
    /**
     * Memory limit.
     */
    limits_memory?: string
    /**
     * Memory swap limit.
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness.
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation.
     */
    limits_memory_reservation?: string
    /**
     * CPU limit.
     */
    limits_cpus?: string
    /**
     * CPU set.
     */
    limits_cpuset?: string
    /**
     * CPU shares.
     */
    limits_cpu_shares?: number
    /**
     * Custom labels.
     */
    custom_labels?: string
    /**
     * Custom docker run options.
     */
    custom_docker_run_options?: string
    /**
     * Post deployment command.
     */
    post_deployment_command?: string
    /**
     * Post deployment command container.
     */
    post_deployment_command_container?: string
    /**
     * Pre deployment command.
     */
    pre_deployment_command?: string
    /**
     * Pre deployment command container.
     */
    pre_deployment_command_container?: string
    /**
     * Manual webhook secret for Github.
     */
    manual_webhook_secret_github?: string
    /**
     * Manual webhook secret for Gitlab.
     */
    manual_webhook_secret_gitlab?: string
    /**
     * Manual webhook secret for Bitbucket.
     */
    manual_webhook_secret_bitbucket?: string
    /**
     * Manual webhook secret for Gitea.
     */
    manual_webhook_secret_gitea?: string
    /**
     * How to set redirect with Traefik / Caddy. www<->non-www.
     */
    redirect?: 'www' | 'non-www' | 'both'
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * HTTP Basic Authentication enabled.
     */
    is_http_basic_auth_enabled?: boolean
    /**
     * Username for HTTP Basic Authentication
     */
    http_basic_auth_username?: string
    /**
     * Password for HTTP Basic Authentication
     */
    http_basic_auth_password?: string
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path?: never
  query?: never
  url: '/applications/dockerimage'
}

export type CreateDockerimageApplicationErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDockerimageApplicationError =
  CreateDockerimageApplicationErrors[keyof CreateDockerimageApplicationErrors]

export type CreateDockerimageApplicationResponses = {
  /**
   * Application created successfully.
   */
  201: {
    uuid?: string
  }
}

export type CreateDockerimageApplicationResponse =
  CreateDockerimageApplicationResponses[keyof CreateDockerimageApplicationResponses]

export type CreateDockercomposeApplicationData = {
  /**
   * Application object that needs to be created.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * The environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw: string
    /**
     * The destination UUID if the server has more than one destinations.
     */
    destination_uuid?: string
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path?: never
  query?: never
  url: '/applications/dockercompose'
}

export type CreateDockercomposeApplicationErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDockercomposeApplicationError =
  CreateDockercomposeApplicationErrors[keyof CreateDockercomposeApplicationErrors]

export type CreateDockercomposeApplicationResponses = {
  /**
   * Application created successfully.
   */
  201: {
    uuid?: string
  }
}

export type CreateDockercomposeApplicationResponse =
  CreateDockercomposeApplicationResponses[keyof CreateDockercomposeApplicationResponses]

export type DeleteApplicationByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: {
    /**
     * Delete configurations.
     */
    delete_configurations?: boolean
    /**
     * Delete volumes.
     */
    delete_volumes?: boolean
    /**
     * Run docker cleanup.
     */
    docker_cleanup?: boolean
    /**
     * Delete connected networks.
     */
    delete_connected_networks?: boolean
  }
  url: '/applications/{uuid}'
}

export type DeleteApplicationByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteApplicationByUuidError =
  DeleteApplicationByUuidErrors[keyof DeleteApplicationByUuidErrors]

export type DeleteApplicationByUuidResponses = {
  /**
   * Application deleted.
   */
  200: {
    message?: string
  }
}

export type DeleteApplicationByUuidResponse =
  DeleteApplicationByUuidResponses[keyof DeleteApplicationByUuidResponses]

export type GetApplicationByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}'
}

export type GetApplicationByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetApplicationByUuidError =
  GetApplicationByUuidErrors[keyof GetApplicationByUuidErrors]

export type GetApplicationByUuidResponses = {
  /**
   * Get application by UUID.
   */
  200: Application
}

export type GetApplicationByUuidResponse =
  GetApplicationByUuidResponses[keyof GetApplicationByUuidResponses]

export type UpdateApplicationByUuidData = {
  /**
   * Application updated.
   */
  body: {
    /**
     * The project UUID.
     */
    project_uuid?: string
    /**
     * The server UUID.
     */
    server_uuid?: string
    /**
     * The environment name.
     */
    environment_name?: string
    /**
     * The Github App UUID.
     */
    github_app_uuid?: string
    /**
     * The git repository URL.
     */
    git_repository?: string
    /**
     * The git branch.
     */
    git_branch?: string
    /**
     * The ports to expose.
     */
    ports_exposes?: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The build pack type.
     */
    build_pack?: 'nixpacks' | 'static' | 'dockerfile' | 'dockercompose'
    /**
     * The application name.
     */
    name?: string
    /**
     * The application description.
     */
    description?: string
    /**
     * The application domains.
     */
    domains?: string
    /**
     * The git commit SHA.
     */
    git_commit_sha?: string
    /**
     * The docker registry image name.
     */
    docker_registry_image_name?: string
    /**
     * The docker registry image tag.
     */
    docker_registry_image_tag?: string
    /**
     * The flag to indicate if the application is static.
     */
    is_static?: boolean
    /**
     * The install command.
     */
    install_command?: string
    /**
     * The build command.
     */
    build_command?: string
    /**
     * The start command.
     */
    start_command?: string
    /**
     * The ports mappings.
     */
    ports_mappings?: string
    /**
     * The base directory for all commands.
     */
    base_directory?: string
    /**
     * The publish directory.
     */
    publish_directory?: string
    /**
     * Health check enabled.
     */
    health_check_enabled?: boolean
    /**
     * Health check path.
     */
    health_check_path?: string
    /**
     * Health check port.
     */
    health_check_port?: string
    /**
     * Health check host.
     */
    health_check_host?: string
    /**
     * Health check method.
     */
    health_check_method?: string
    /**
     * Health check return code.
     */
    health_check_return_code?: number
    /**
     * Health check scheme.
     */
    health_check_scheme?: string
    /**
     * Health check response text.
     */
    health_check_response_text?: string
    /**
     * Health check interval in seconds.
     */
    health_check_interval?: number
    /**
     * Health check timeout in seconds.
     */
    health_check_timeout?: number
    /**
     * Health check retries count.
     */
    health_check_retries?: number
    /**
     * Health check start period in seconds.
     */
    health_check_start_period?: number
    /**
     * Memory limit.
     */
    limits_memory?: string
    /**
     * Memory swap limit.
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness.
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation.
     */
    limits_memory_reservation?: string
    /**
     * CPU limit.
     */
    limits_cpus?: string
    /**
     * CPU set.
     */
    limits_cpuset?: string
    /**
     * CPU shares.
     */
    limits_cpu_shares?: number
    /**
     * Custom labels.
     */
    custom_labels?: string
    /**
     * Custom docker run options.
     */
    custom_docker_run_options?: string
    /**
     * Post deployment command.
     */
    post_deployment_command?: string
    /**
     * Post deployment command container.
     */
    post_deployment_command_container?: string
    /**
     * Pre deployment command.
     */
    pre_deployment_command?: string
    /**
     * Pre deployment command container.
     */
    pre_deployment_command_container?: string
    /**
     * Manual webhook secret for Github.
     */
    manual_webhook_secret_github?: string
    /**
     * Manual webhook secret for Gitlab.
     */
    manual_webhook_secret_gitlab?: string
    /**
     * Manual webhook secret for Bitbucket.
     */
    manual_webhook_secret_bitbucket?: string
    /**
     * Manual webhook secret for Gitea.
     */
    manual_webhook_secret_gitea?: string
    /**
     * How to set redirect with Traefik / Caddy. www<->non-www.
     */
    redirect?: 'www' | 'non-www' | 'both'
    /**
     * The flag to indicate if the application should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * The Dockerfile content.
     */
    dockerfile?: string
    /**
     * The Docker Compose location.
     */
    docker_compose_location?: string
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw?: string
    /**
     * The Docker Compose custom start command.
     */
    docker_compose_custom_start_command?: string
    /**
     * The Docker Compose custom build command.
     */
    docker_compose_custom_build_command?: string
    /**
     * The Docker Compose domains.
     */
    docker_compose_domains?: Array<unknown>
    /**
     * The watch paths.
     */
    watch_paths?: string
    /**
     * Use build server.
     */
    use_build_server?: boolean
    /**
     * The flag to connect the service to the predefined Docker network.
     */
    connect_to_docker_network?: boolean
  }
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}'
}

export type UpdateApplicationByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateApplicationByUuidError =
  UpdateApplicationByUuidErrors[keyof UpdateApplicationByUuidErrors]

export type UpdateApplicationByUuidResponses = {
  /**
   * Application updated.
   */
  200: {
    uuid?: string
  }
}

export type UpdateApplicationByUuidResponse =
  UpdateApplicationByUuidResponses[keyof UpdateApplicationByUuidResponses]

export type GetApplicationLogsByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: {
    /**
     * Number of lines to show from the end of the logs.
     */
    lines?: number
  }
  url: '/applications/{uuid}/logs'
}

export type GetApplicationLogsByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetApplicationLogsByUuidError =
  GetApplicationLogsByUuidErrors[keyof GetApplicationLogsByUuidErrors]

export type GetApplicationLogsByUuidResponses = {
  /**
   * Get application logs by UUID.
   */
  200: {
    logs?: string
  }
}

export type GetApplicationLogsByUuidResponse =
  GetApplicationLogsByUuidResponses[keyof GetApplicationLogsByUuidResponses]

export type ListEnvsByApplicationUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}/envs'
}

export type ListEnvsByApplicationUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type ListEnvsByApplicationUuidError =
  ListEnvsByApplicationUuidErrors[keyof ListEnvsByApplicationUuidErrors]

export type ListEnvsByApplicationUuidResponses = {
  /**
   * All environment variables by application UUID.
   */
  200: Array<EnvironmentVariable>
}

export type ListEnvsByApplicationUuidResponse =
  ListEnvsByApplicationUuidResponses[keyof ListEnvsByApplicationUuidResponses]

export type UpdateEnvByApplicationUuidData = {
  /**
   * Env updated.
   */
  body: {
    /**
     * The key of the environment variable.
     */
    key: string
    /**
     * The value of the environment variable.
     */
    value: string
    /**
     * The flag to indicate if the environment variable is used in preview deployments.
     */
    is_preview?: boolean
    /**
     * The flag to indicate if the environment variable is used in build time.
     */
    is_build_time?: boolean
    /**
     * The flag to indicate if the environment variable is a literal, nothing espaced.
     */
    is_literal?: boolean
    /**
     * The flag to indicate if the environment variable is multiline.
     */
    is_multiline?: boolean
    /**
     * The flag to indicate if the environment variable's value is shown on the UI.
     */
    is_shown_once?: boolean
  }
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}/envs'
}

export type UpdateEnvByApplicationUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateEnvByApplicationUuidError =
  UpdateEnvByApplicationUuidErrors[keyof UpdateEnvByApplicationUuidErrors]

export type UpdateEnvByApplicationUuidResponses = {
  /**
   * Environment variable updated.
   */
  201: {
    message?: string
  }
}

export type UpdateEnvByApplicationUuidResponse =
  UpdateEnvByApplicationUuidResponses[keyof UpdateEnvByApplicationUuidResponses]

export type CreateEnvByApplicationUuidData = {
  /**
   * Env created.
   */
  body: {
    /**
     * The key of the environment variable.
     */
    key?: string
    /**
     * The value of the environment variable.
     */
    value?: string
    /**
     * The flag to indicate if the environment variable is used in preview deployments.
     */
    is_preview?: boolean
    /**
     * The flag to indicate if the environment variable is used in build time.
     */
    is_build_time?: boolean
    /**
     * The flag to indicate if the environment variable is a literal, nothing espaced.
     */
    is_literal?: boolean
    /**
     * The flag to indicate if the environment variable is multiline.
     */
    is_multiline?: boolean
    /**
     * The flag to indicate if the environment variable's value is shown on the UI.
     */
    is_shown_once?: boolean
  }
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}/envs'
}

export type CreateEnvByApplicationUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type CreateEnvByApplicationUuidError =
  CreateEnvByApplicationUuidErrors[keyof CreateEnvByApplicationUuidErrors]

export type CreateEnvByApplicationUuidResponses = {
  /**
   * Environment variable created.
   */
  201: {
    uuid?: string
  }
}

export type CreateEnvByApplicationUuidResponse =
  CreateEnvByApplicationUuidResponses[keyof CreateEnvByApplicationUuidResponses]

export type UpdateEnvsByApplicationUuidData = {
  /**
   * Bulk envs updated.
   */
  body: {
    data: Array<{
      /**
       * The key of the environment variable.
       */
      key?: string
      /**
       * The value of the environment variable.
       */
      value?: string
      /**
       * The flag to indicate if the environment variable is used in preview deployments.
       */
      is_preview?: boolean
      /**
       * The flag to indicate if the environment variable is used in build time.
       */
      is_build_time?: boolean
      /**
       * The flag to indicate if the environment variable is a literal, nothing espaced.
       */
      is_literal?: boolean
      /**
       * The flag to indicate if the environment variable is multiline.
       */
      is_multiline?: boolean
      /**
       * The flag to indicate if the environment variable's value is shown on the UI.
       */
      is_shown_once?: boolean
    }>
  }
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}/envs/bulk'
}

export type UpdateEnvsByApplicationUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateEnvsByApplicationUuidError =
  UpdateEnvsByApplicationUuidErrors[keyof UpdateEnvsByApplicationUuidErrors]

export type UpdateEnvsByApplicationUuidResponses = {
  /**
   * Environment variables updated.
   */
  201: {
    message?: string
  }
}

export type UpdateEnvsByApplicationUuidResponse =
  UpdateEnvsByApplicationUuidResponses[keyof UpdateEnvsByApplicationUuidResponses]

export type DeleteEnvByApplicationUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
    /**
     * UUID of the environment variable.
     */
    env_uuid: string
  }
  query?: never
  url: '/applications/{uuid}/envs/{env_uuid}'
}

export type DeleteEnvByApplicationUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteEnvByApplicationUuidError =
  DeleteEnvByApplicationUuidErrors[keyof DeleteEnvByApplicationUuidErrors]

export type DeleteEnvByApplicationUuidResponses = {
  /**
   * Environment variable deleted.
   */
  200: {
    message?: string
  }
}

export type DeleteEnvByApplicationUuidResponse =
  DeleteEnvByApplicationUuidResponses[keyof DeleteEnvByApplicationUuidResponses]

export type StartApplicationByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: {
    /**
     * Force rebuild.
     */
    force?: boolean
    /**
     * Instant deploy (skip queuing).
     */
    instant_deploy?: boolean
  }
  url: '/applications/{uuid}/start'
}

export type StartApplicationByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type StartApplicationByUuidError =
  StartApplicationByUuidErrors[keyof StartApplicationByUuidErrors]

export type StartApplicationByUuidResponses = {
  /**
   * Start application.
   */
  200: {
    /**
     * Message.
     */
    message?: string
    /**
     * UUID of the deployment.
     */
    deployment_uuid?: string
  }
}

export type StartApplicationByUuidResponse =
  StartApplicationByUuidResponses[keyof StartApplicationByUuidResponses]

export type StopApplicationByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}/stop'
}

export type StopApplicationByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type StopApplicationByUuidError =
  StopApplicationByUuidErrors[keyof StopApplicationByUuidErrors]

export type StopApplicationByUuidResponses = {
  /**
   * Stop application.
   */
  200: {
    message?: string
  }
}

export type StopApplicationByUuidResponse =
  StopApplicationByUuidResponses[keyof StopApplicationByUuidResponses]

export type RestartApplicationByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/applications/{uuid}/restart'
}

export type RestartApplicationByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type RestartApplicationByUuidError =
  RestartApplicationByUuidErrors[keyof RestartApplicationByUuidErrors]

export type RestartApplicationByUuidResponses = {
  /**
   * Restart application.
   */
  200: {
    message?: string
    /**
     * UUID of the deployment.
     */
    deployment_uuid?: string
  }
}

export type RestartApplicationByUuidResponse =
  RestartApplicationByUuidResponses[keyof RestartApplicationByUuidResponses]

export type ListDatabasesData = {
  body?: never
  path?: never
  query?: never
  url: '/databases'
}

export type ListDatabasesErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListDatabasesError = ListDatabasesErrors[keyof ListDatabasesErrors]

export type ListDatabasesResponses = {
  /**
   * Get all databases
   */
  200: string
}

export type ListDatabasesResponse =
  ListDatabasesResponses[keyof ListDatabasesResponses]

export type DeleteDatabaseByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the database.
     */
    uuid: string
  }
  query?: {
    /**
     * Delete configurations.
     */
    delete_configurations?: boolean
    /**
     * Delete volumes.
     */
    delete_volumes?: boolean
    /**
     * Run docker cleanup.
     */
    docker_cleanup?: boolean
    /**
     * Delete connected networks.
     */
    delete_connected_networks?: boolean
  }
  url: '/databases/{uuid}'
}

export type DeleteDatabaseByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteDatabaseByUuidError =
  DeleteDatabaseByUuidErrors[keyof DeleteDatabaseByUuidErrors]

export type DeleteDatabaseByUuidResponses = {
  /**
   * Database deleted.
   */
  200: {
    message?: string
  }
}

export type DeleteDatabaseByUuidResponse =
  DeleteDatabaseByUuidResponses[keyof DeleteDatabaseByUuidResponses]

export type GetDatabaseByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the database.
     */
    uuid: string
  }
  query?: never
  url: '/databases/{uuid}'
}

export type GetDatabaseByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetDatabaseByUuidError =
  GetDatabaseByUuidErrors[keyof GetDatabaseByUuidErrors]

export type GetDatabaseByUuidResponses = {
  /**
   * Get all databases
   */
  200: string
}

export type GetDatabaseByUuidResponse =
  GetDatabaseByUuidResponses[keyof GetDatabaseByUuidResponses]

export type UpdateDatabaseByUuidData = {
  /**
   * Database data
   */
  body: {
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * PostgreSQL user
     */
    postgres_user?: string
    /**
     * PostgreSQL password
     */
    postgres_password?: string
    /**
     * PostgreSQL database
     */
    postgres_db?: string
    /**
     * PostgreSQL initdb args
     */
    postgres_initdb_args?: string
    /**
     * PostgreSQL host auth method
     */
    postgres_host_auth_method?: string
    /**
     * PostgreSQL conf
     */
    postgres_conf?: string
    /**
     * Clickhouse admin user
     */
    clickhouse_admin_user?: string
    /**
     * Clickhouse admin password
     */
    clickhouse_admin_password?: string
    /**
     * DragonFly password
     */
    dragonfly_password?: string
    /**
     * Redis password
     */
    redis_password?: string
    /**
     * Redis conf
     */
    redis_conf?: string
    /**
     * KeyDB password
     */
    keydb_password?: string
    /**
     * KeyDB conf
     */
    keydb_conf?: string
    /**
     * MariaDB conf
     */
    mariadb_conf?: string
    /**
     * MariaDB root password
     */
    mariadb_root_password?: string
    /**
     * MariaDB user
     */
    mariadb_user?: string
    /**
     * MariaDB password
     */
    mariadb_password?: string
    /**
     * MariaDB database
     */
    mariadb_database?: string
    /**
     * Mongo conf
     */
    mongo_conf?: string
    /**
     * Mongo initdb root username
     */
    mongo_initdb_root_username?: string
    /**
     * Mongo initdb root password
     */
    mongo_initdb_root_password?: string
    /**
     * Mongo initdb init database
     */
    mongo_initdb_database?: string
    /**
     * MySQL root password
     */
    mysql_root_password?: string
    /**
     * MySQL password
     */
    mysql_password?: string
    /**
     * MySQL user
     */
    mysql_user?: string
    /**
     * MySQL database
     */
    mysql_database?: string
    /**
     * MySQL conf
     */
    mysql_conf?: string
  }
  path: {
    /**
     * UUID of the database.
     */
    uuid: string
  }
  query?: never
  url: '/databases/{uuid}'
}

export type UpdateDatabaseByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateDatabaseByUuidError =
  UpdateDatabaseByUuidErrors[keyof UpdateDatabaseByUuidErrors]

export type UpdateDatabaseByUuidResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabasePostgresqlData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * PostgreSQL user
     */
    postgres_user?: string
    /**
     * PostgreSQL password
     */
    postgres_password?: string
    /**
     * PostgreSQL database
     */
    postgres_db?: string
    /**
     * PostgreSQL initdb args
     */
    postgres_initdb_args?: string
    /**
     * PostgreSQL host auth method
     */
    postgres_host_auth_method?: string
    /**
     * PostgreSQL conf
     */
    postgres_conf?: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/postgresql'
}

export type CreateDatabasePostgresqlErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabasePostgresqlError =
  CreateDatabasePostgresqlErrors[keyof CreateDatabasePostgresqlErrors]

export type CreateDatabasePostgresqlResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseClickhouseData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * Clickhouse admin user
     */
    clickhouse_admin_user?: string
    /**
     * Clickhouse admin password
     */
    clickhouse_admin_password?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/clickhouse'
}

export type CreateDatabaseClickhouseErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseClickhouseError =
  CreateDatabaseClickhouseErrors[keyof CreateDatabaseClickhouseErrors]

export type CreateDatabaseClickhouseResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseDragonflyData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * DragonFly password
     */
    dragonfly_password?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/dragonfly'
}

export type CreateDatabaseDragonflyErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseDragonflyError =
  CreateDatabaseDragonflyErrors[keyof CreateDatabaseDragonflyErrors]

export type CreateDatabaseDragonflyResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseRedisData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * Redis password
     */
    redis_password?: string
    /**
     * Redis conf
     */
    redis_conf?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/redis'
}

export type CreateDatabaseRedisErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseRedisError =
  CreateDatabaseRedisErrors[keyof CreateDatabaseRedisErrors]

export type CreateDatabaseRedisResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseKeydbData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * KeyDB password
     */
    keydb_password?: string
    /**
     * KeyDB conf
     */
    keydb_conf?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/keydb'
}

export type CreateDatabaseKeydbErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseKeydbError =
  CreateDatabaseKeydbErrors[keyof CreateDatabaseKeydbErrors]

export type CreateDatabaseKeydbResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseMariadbData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * MariaDB conf
     */
    mariadb_conf?: string
    /**
     * MariaDB root password
     */
    mariadb_root_password?: string
    /**
     * MariaDB user
     */
    mariadb_user?: string
    /**
     * MariaDB password
     */
    mariadb_password?: string
    /**
     * MariaDB database
     */
    mariadb_database?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/mariadb'
}

export type CreateDatabaseMariadbErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseMariadbError =
  CreateDatabaseMariadbErrors[keyof CreateDatabaseMariadbErrors]

export type CreateDatabaseMariadbResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseMysqlData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * MySQL root password
     */
    mysql_root_password?: string
    /**
     * MySQL password
     */
    mysql_password?: string
    /**
     * MySQL user
     */
    mysql_user?: string
    /**
     * MySQL database
     */
    mysql_database?: string
    /**
     * MySQL conf
     */
    mysql_conf?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/mysql'
}

export type CreateDatabaseMysqlErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseMysqlError =
  CreateDatabaseMysqlErrors[keyof CreateDatabaseMysqlErrors]

export type CreateDatabaseMysqlResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type CreateDatabaseMongodbData = {
  /**
   * Database data
   */
  body: {
    /**
     * UUID of the server
     */
    server_uuid: string
    /**
     * UUID of the project
     */
    project_uuid: string
    /**
     * Name of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * UUID of the environment. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * UUID of the destination if the server has multiple destinations
     */
    destination_uuid?: string
    /**
     * MongoDB conf
     */
    mongo_conf?: string
    /**
     * MongoDB initdb root username
     */
    mongo_initdb_root_username?: string
    /**
     * Name of the database
     */
    name?: string
    /**
     * Description of the database
     */
    description?: string
    /**
     * Docker Image of the database
     */
    image?: string
    /**
     * Is the database public?
     */
    is_public?: boolean
    /**
     * Public port of the database
     */
    public_port?: number
    /**
     * Memory limit of the database
     */
    limits_memory?: string
    /**
     * Memory swap limit of the database
     */
    limits_memory_swap?: string
    /**
     * Memory swappiness of the database
     */
    limits_memory_swappiness?: number
    /**
     * Memory reservation of the database
     */
    limits_memory_reservation?: string
    /**
     * CPU limit of the database
     */
    limits_cpus?: string
    /**
     * CPU set of the database
     */
    limits_cpuset?: string
    /**
     * CPU shares of the database
     */
    limits_cpu_shares?: number
    /**
     * Instant deploy the database
     */
    instant_deploy?: boolean
  }
  path?: never
  query?: never
  url: '/databases/mongodb'
}

export type CreateDatabaseMongodbErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateDatabaseMongodbError =
  CreateDatabaseMongodbErrors[keyof CreateDatabaseMongodbErrors]

export type CreateDatabaseMongodbResponses = {
  /**
   * Database updated
   */
  200: unknown
}

export type StartDatabaseByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the database.
     */
    uuid: string
  }
  query?: never
  url: '/databases/{uuid}/start'
}

export type StartDatabaseByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type StartDatabaseByUuidError =
  StartDatabaseByUuidErrors[keyof StartDatabaseByUuidErrors]

export type StartDatabaseByUuidResponses = {
  /**
   * Start database.
   */
  200: {
    message?: string
  }
}

export type StartDatabaseByUuidResponse =
  StartDatabaseByUuidResponses[keyof StartDatabaseByUuidResponses]

export type StopDatabaseByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the database.
     */
    uuid: string
  }
  query?: never
  url: '/databases/{uuid}/stop'
}

export type StopDatabaseByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type StopDatabaseByUuidError =
  StopDatabaseByUuidErrors[keyof StopDatabaseByUuidErrors]

export type StopDatabaseByUuidResponses = {
  /**
   * Stop database.
   */
  200: {
    message?: string
  }
}

export type StopDatabaseByUuidResponse =
  StopDatabaseByUuidResponses[keyof StopDatabaseByUuidResponses]

export type RestartDatabaseByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the database.
     */
    uuid: string
  }
  query?: never
  url: '/databases/{uuid}/restart'
}

export type RestartDatabaseByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type RestartDatabaseByUuidError =
  RestartDatabaseByUuidErrors[keyof RestartDatabaseByUuidErrors]

export type RestartDatabaseByUuidResponses = {
  /**
   * Restart database.
   */
  200: {
    message?: string
  }
}

export type RestartDatabaseByUuidResponse =
  RestartDatabaseByUuidResponses[keyof RestartDatabaseByUuidResponses]

export type ListDeploymentsData = {
  body?: never
  path?: never
  query?: never
  url: '/deployments'
}

export type ListDeploymentsErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListDeploymentsError =
  ListDeploymentsErrors[keyof ListDeploymentsErrors]

export type ListDeploymentsResponses = {
  /**
   * Get all currently running deployments.
   */
  200: Array<ApplicationDeploymentQueue>
}

export type ListDeploymentsResponse =
  ListDeploymentsResponses[keyof ListDeploymentsResponses]

export type GetDeploymentByUuidData = {
  body?: never
  path: {
    /**
     * Deployment UUID
     */
    uuid: string
  }
  query?: never
  url: '/deployments/{uuid}'
}

export type GetDeploymentByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetDeploymentByUuidError =
  GetDeploymentByUuidErrors[keyof GetDeploymentByUuidErrors]

export type GetDeploymentByUuidResponses = {
  /**
   * Get deployment by UUID.
   */
  200: ApplicationDeploymentQueue
}

export type GetDeploymentByUuidResponse =
  GetDeploymentByUuidResponses[keyof GetDeploymentByUuidResponses]

export type DeployByTagOrUuidData = {
  body?: never
  path?: never
  query?: {
    /**
     * Tag name(s). Comma separated list is also accepted.
     */
    tag?: string
    /**
     * Resource UUID(s). Comma separated list is also accepted.
     */
    uuid?: string
    /**
     * Force rebuild (without cache)
     */
    force?: boolean
    /**
     * Pull Request Id for deploying specific PR builds. Cannot be used with tag parameter.
     */
    pr?: number
  }
  url: '/deploy'
}

export type DeployByTagOrUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type DeployByTagOrUuidError =
  DeployByTagOrUuidErrors[keyof DeployByTagOrUuidErrors]

export type DeployByTagOrUuidResponses = {
  /**
   * Get deployment(s) UUID's
   */
  200: {
    deployments?: Array<{
      message?: string
      resource_uuid?: string
      deployment_uuid?: string
    }>
  }
}

export type DeployByTagOrUuidResponse =
  DeployByTagOrUuidResponses[keyof DeployByTagOrUuidResponses]

export type ListDeploymentsByAppUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: {
    /**
     * Number of records to skip.
     */
    skip?: number
    /**
     * Number of records to take.
     */
    take?: number
  }
  url: '/deployments/applications/{uuid}'
}

export type ListDeploymentsByAppUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListDeploymentsByAppUuidError =
  ListDeploymentsByAppUuidErrors[keyof ListDeploymentsByAppUuidErrors]

export type ListDeploymentsByAppUuidResponses = {
  /**
   * List application deployments by using the app uuid.
   */
  200: Array<Application>
}

export type ListDeploymentsByAppUuidResponse =
  ListDeploymentsByAppUuidResponses[keyof ListDeploymentsByAppUuidResponses]

export type VersionData = {
  body?: never
  path?: never
  query?: never
  url: '/version'
}

export type VersionErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type VersionError = VersionErrors[keyof VersionErrors]

export type VersionResponses = {
  /**
   * Returns the version of the application
   */
  200: string
}

export type VersionResponse = VersionResponses[keyof VersionResponses]

export type EnableApiData = {
  body?: never
  path?: never
  query?: never
  url: '/enable'
}

export type EnableApiErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * You are not allowed to enable the API.
   */
  403: {
    message?: string
  }
}

export type EnableApiError = EnableApiErrors[keyof EnableApiErrors]

export type EnableApiResponses = {
  /**
   * Enable API.
   */
  200: {
    message?: string
  }
}

export type EnableApiResponse = EnableApiResponses[keyof EnableApiResponses]

export type DisableApiData = {
  body?: never
  path?: never
  query?: never
  url: '/disable'
}

export type DisableApiErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * You are not allowed to disable the API.
   */
  403: {
    message?: string
  }
}

export type DisableApiError = DisableApiErrors[keyof DisableApiErrors]

export type DisableApiResponses = {
  /**
   * Disable API.
   */
  200: {
    message?: string
  }
}

export type DisableApiResponse = DisableApiResponses[keyof DisableApiResponses]

export type HealthcheckData = {
  body?: never
  path?: never
  query?: never
  url: '/health'
}

export type HealthcheckErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type HealthcheckError = HealthcheckErrors[keyof HealthcheckErrors]

export type HealthcheckResponses = {
  /**
   * Healthcheck endpoint.
   */
  200: string
}

export type HealthcheckResponse =
  HealthcheckResponses[keyof HealthcheckResponses]

export type ListProjectsData = {
  body?: never
  path?: never
  query?: never
  url: '/projects'
}

export type ListProjectsErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListProjectsError = ListProjectsErrors[keyof ListProjectsErrors]

export type ListProjectsResponses = {
  /**
   * Get all projects.
   */
  200: Array<Project>
}

export type ListProjectsResponse =
  ListProjectsResponses[keyof ListProjectsResponses]

export type CreateProjectData = {
  /**
   * Project created.
   */
  body: {
    /**
     * The name of the project.
     */
    name?: string
    /**
     * The description of the project.
     */
    description?: string
  }
  path?: never
  query?: never
  url: '/projects'
}

export type CreateProjectErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type CreateProjectError = CreateProjectErrors[keyof CreateProjectErrors]

export type CreateProjectResponses = {
  /**
   * Project created.
   */
  201: {
    /**
     * The UUID of the project.
     */
    uuid?: string
  }
}

export type CreateProjectResponse =
  CreateProjectResponses[keyof CreateProjectResponses]

export type DeleteProjectByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the application.
     */
    uuid: string
  }
  query?: never
  url: '/projects/{uuid}'
}

export type DeleteProjectByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteProjectByUuidError =
  DeleteProjectByUuidErrors[keyof DeleteProjectByUuidErrors]

export type DeleteProjectByUuidResponses = {
  /**
   * Project deleted.
   */
  200: {
    message?: string
  }
}

export type DeleteProjectByUuidResponse =
  DeleteProjectByUuidResponses[keyof DeleteProjectByUuidResponses]

export type GetProjectByUuidData = {
  body?: never
  path: {
    /**
     * Project UUID
     */
    uuid: string
  }
  query?: never
  url: '/projects/{uuid}'
}

export type GetProjectByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Project not found.
   */
  404: unknown
}

export type GetProjectByUuidError =
  GetProjectByUuidErrors[keyof GetProjectByUuidErrors]

export type GetProjectByUuidResponses = {
  /**
   * Project details
   */
  200: Project
}

export type GetProjectByUuidResponse =
  GetProjectByUuidResponses[keyof GetProjectByUuidResponses]

export type UpdateProjectByUuidData = {
  /**
   * Project updated.
   */
  body: {
    /**
     * The name of the project.
     */
    name?: string
    /**
     * The description of the project.
     */
    description?: string
  }
  path: {
    /**
     * UUID of the project.
     */
    uuid: string
  }
  query?: never
  url: '/projects/{uuid}'
}

export type UpdateProjectByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateProjectByUuidError =
  UpdateProjectByUuidErrors[keyof UpdateProjectByUuidErrors]

export type UpdateProjectByUuidResponses = {
  /**
   * Project updated.
   */
  201: {
    uuid?: string
    name?: string
    description?: string
  }
}

export type UpdateProjectByUuidResponse =
  UpdateProjectByUuidResponses[keyof UpdateProjectByUuidResponses]

export type GetEnvironmentByNameOrUuidData = {
  body?: never
  path: {
    /**
     * Project UUID
     */
    uuid: string
    /**
     * Environment name or UUID
     */
    environment_name_or_uuid: string
  }
  query?: never
  url: '/projects/{uuid}/{environment_name_or_uuid}'
}

export type GetEnvironmentByNameOrUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetEnvironmentByNameOrUuidError =
  GetEnvironmentByNameOrUuidErrors[keyof GetEnvironmentByNameOrUuidErrors]

export type GetEnvironmentByNameOrUuidResponses = {
  /**
   * Environment details
   */
  200: Environment
}

export type GetEnvironmentByNameOrUuidResponse =
  GetEnvironmentByNameOrUuidResponses[keyof GetEnvironmentByNameOrUuidResponses]

export type ListResourcesData = {
  body?: never
  path?: never
  query?: never
  url: '/resources'
}

export type ListResourcesErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListResourcesError = ListResourcesErrors[keyof ListResourcesErrors]

export type ListResourcesResponses = {
  /**
   * Get all resources
   */
  200: string
}

export type ListResourcesResponse =
  ListResourcesResponses[keyof ListResourcesResponses]

export type ListPrivateKeysData = {
  body?: never
  path?: never
  query?: never
  url: '/security/keys'
}

export type ListPrivateKeysErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListPrivateKeysError =
  ListPrivateKeysErrors[keyof ListPrivateKeysErrors]

export type ListPrivateKeysResponses = {
  /**
   * Get all private keys.
   */
  200: Array<PrivateKey>
}

export type ListPrivateKeysResponse =
  ListPrivateKeysResponses[keyof ListPrivateKeysResponses]

export type UpdatePrivateKeyData = {
  body: {
    name?: string
    description?: string
    private_key: string
  }
  path?: never
  query?: never
  url: '/security/keys'
}

export type UpdatePrivateKeyErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type UpdatePrivateKeyError =
  UpdatePrivateKeyErrors[keyof UpdatePrivateKeyErrors]

export type UpdatePrivateKeyResponses = {
  /**
   * The updated private key's UUID.
   */
  201: {
    uuid?: string
  }
}

export type UpdatePrivateKeyResponse =
  UpdatePrivateKeyResponses[keyof UpdatePrivateKeyResponses]

export type CreatePrivateKeyData = {
  body: {
    name?: string
    description?: string
    private_key: string
  }
  path?: never
  query?: never
  url: '/security/keys'
}

export type CreatePrivateKeyErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreatePrivateKeyError =
  CreatePrivateKeyErrors[keyof CreatePrivateKeyErrors]

export type CreatePrivateKeyResponses = {
  /**
   * The created private key's UUID.
   */
  201: {
    uuid?: string
  }
}

export type CreatePrivateKeyResponse =
  CreatePrivateKeyResponses[keyof CreatePrivateKeyResponses]

export type DeletePrivateKeyByUuidData = {
  body?: never
  path: {
    /**
     * Private Key UUID
     */
    uuid: string
  }
  query?: never
  url: '/security/keys/{uuid}'
}

export type DeletePrivateKeyByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Private Key not found.
   */
  404: unknown
  /**
   * Private Key is in use and cannot be deleted.
   */
  422: {
    message?: string
  }
}

export type DeletePrivateKeyByUuidError =
  DeletePrivateKeyByUuidErrors[keyof DeletePrivateKeyByUuidErrors]

export type DeletePrivateKeyByUuidResponses = {
  /**
   * Private Key deleted.
   */
  200: {
    message?: string
  }
}

export type DeletePrivateKeyByUuidResponse =
  DeletePrivateKeyByUuidResponses[keyof DeletePrivateKeyByUuidResponses]

export type GetPrivateKeyByUuidData = {
  body?: never
  path: {
    /**
     * Private Key UUID
     */
    uuid: string
  }
  query?: never
  url: '/security/keys/{uuid}'
}

export type GetPrivateKeyByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Private Key not found.
   */
  404: unknown
}

export type GetPrivateKeyByUuidError =
  GetPrivateKeyByUuidErrors[keyof GetPrivateKeyByUuidErrors]

export type GetPrivateKeyByUuidResponses = {
  /**
   * Get all private keys.
   */
  200: PrivateKey
}

export type GetPrivateKeyByUuidResponse =
  GetPrivateKeyByUuidResponses[keyof GetPrivateKeyByUuidResponses]

export type ListServersData = {
  body?: never
  path?: never
  query?: never
  url: '/servers'
}

export type ListServersErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListServersError = ListServersErrors[keyof ListServersErrors]

export type ListServersResponses = {
  /**
   * Get all servers.
   */
  200: Array<Server>
}

export type ListServersResponse =
  ListServersResponses[keyof ListServersResponses]

export type CreateServerData = {
  /**
   * Server created.
   */
  body: {
    /**
     * The name of the server.
     */
    name?: string
    /**
     * The description of the server.
     */
    description?: string
    /**
     * The IP of the server.
     */
    ip?: string
    /**
     * The port of the server.
     */
    port?: number
    /**
     * The user of the server.
     */
    user?: string
    /**
     * The UUID of the private key.
     */
    private_key_uuid?: string
    /**
     * Is build server.
     */
    is_build_server?: boolean
    /**
     * Instant validate.
     */
    instant_validate?: boolean
    /**
     * The proxy type.
     */
    proxy_type?: 'traefik' | 'caddy' | 'none'
  }
  path?: never
  query?: never
  url: '/servers'
}

export type CreateServerErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type CreateServerError = CreateServerErrors[keyof CreateServerErrors]

export type CreateServerResponses = {
  /**
   * Server created.
   */
  201: {
    /**
     * The UUID of the server.
     */
    uuid?: string
  }
}

export type CreateServerResponse =
  CreateServerResponses[keyof CreateServerResponses]

export type DeleteServerByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the server.
     */
    uuid: string
  }
  query?: never
  url: '/servers/{uuid}'
}

export type DeleteServerByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteServerByUuidError =
  DeleteServerByUuidErrors[keyof DeleteServerByUuidErrors]

export type DeleteServerByUuidResponses = {
  /**
   * Server deleted.
   */
  200: {
    message?: string
  }
}

export type DeleteServerByUuidResponse =
  DeleteServerByUuidResponses[keyof DeleteServerByUuidResponses]

export type GetServerByUuidData = {
  body?: never
  path: {
    /**
     * Server's UUID
     */
    uuid: string
  }
  query?: never
  url: '/servers/{uuid}'
}

export type GetServerByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetServerByUuidError =
  GetServerByUuidErrors[keyof GetServerByUuidErrors]

export type GetServerByUuidResponses = {
  /**
   * Get server by UUID
   */
  200: Server
}

export type GetServerByUuidResponse =
  GetServerByUuidResponses[keyof GetServerByUuidResponses]

export type UpdateServerByUuidData = {
  /**
   * Server updated.
   */
  body: {
    /**
     * The name of the server.
     */
    name?: string
    /**
     * The description of the server.
     */
    description?: string
    /**
     * The IP of the server.
     */
    ip?: string
    /**
     * The port of the server.
     */
    port?: number
    /**
     * The user of the server.
     */
    user?: string
    /**
     * The UUID of the private key.
     */
    private_key_uuid?: string
    /**
     * Is build server.
     */
    is_build_server?: boolean
    /**
     * Instant validate.
     */
    instant_validate?: boolean
    /**
     * The proxy type.
     */
    proxy_type?: 'traefik' | 'caddy' | 'none'
  }
  path: {
    /**
     * Server UUID
     */
    uuid: string
  }
  query?: never
  url: '/servers/{uuid}'
}

export type UpdateServerByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateServerByUuidError =
  UpdateServerByUuidErrors[keyof UpdateServerByUuidErrors]

export type UpdateServerByUuidResponses = {
  /**
   * Server updated.
   */
  201: Server
}

export type UpdateServerByUuidResponse =
  UpdateServerByUuidResponses[keyof UpdateServerByUuidResponses]

export type GetResourcesByServerUuidData = {
  body?: never
  path: {
    /**
     * Server's UUID
     */
    uuid: string
  }
  query?: never
  url: '/servers/{uuid}/resources'
}

export type GetResourcesByServerUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type GetResourcesByServerUuidError =
  GetResourcesByServerUuidErrors[keyof GetResourcesByServerUuidErrors]

export type GetResourcesByServerUuidResponses = {
  /**
   * Get resources by server
   */
  200: Array<{
    id?: number
    uuid?: string
    name?: string
    type?: string
    created_at?: string
    updated_at?: string
    status?: string
  }>
}

export type GetResourcesByServerUuidResponse =
  GetResourcesByServerUuidResponses[keyof GetResourcesByServerUuidResponses]

export type GetDomainsByServerUuidData = {
  body?: never
  path: {
    /**
     * Server's UUID
     */
    uuid: string
  }
  query?: never
  url: '/servers/{uuid}/domains'
}

export type GetDomainsByServerUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type GetDomainsByServerUuidError =
  GetDomainsByServerUuidErrors[keyof GetDomainsByServerUuidErrors]

export type GetDomainsByServerUuidResponses = {
  /**
   * Get domains by server
   */
  200: Array<{
    ip?: string
    domains?: Array<string>
  }>
}

export type GetDomainsByServerUuidResponse =
  GetDomainsByServerUuidResponses[keyof GetDomainsByServerUuidResponses]

export type ValidateServerByUuidData = {
  body?: never
  path: {
    /**
     * Server UUID
     */
    uuid: string
  }
  query?: never
  url: '/servers/{uuid}/validate'
}

export type ValidateServerByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type ValidateServerByUuidError =
  ValidateServerByUuidErrors[keyof ValidateServerByUuidErrors]

export type ValidateServerByUuidResponses = {
  /**
   * Server validation started.
   */
  201: {
    message?: string
  }
}

export type ValidateServerByUuidResponse =
  ValidateServerByUuidResponses[keyof ValidateServerByUuidResponses]

export type ListServicesData = {
  body?: never
  path?: never
  query?: never
  url: '/services'
}

export type ListServicesErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListServicesError = ListServicesErrors[keyof ListServicesErrors]

export type ListServicesResponses = {
  /**
   * Get all services
   */
  200: Array<Service>
}

export type ListServicesResponse =
  ListServicesResponses[keyof ListServicesResponses]

export type CreateServiceData = {
  body: {
    /**
     * The one-click service type
     */
    type?:
      | 'activepieces'
      | 'appsmith'
      | 'appwrite'
      | 'authentik'
      | 'babybuddy'
      | 'budge'
      | 'changedetection'
      | 'chatwoot'
      | 'classicpress-with-mariadb'
      | 'classicpress-with-mysql'
      | 'classicpress-without-database'
      | 'cloudflared'
      | 'code-server'
      | 'dashboard'
      | 'directus'
      | 'directus-with-postgresql'
      | 'docker-registry'
      | 'docuseal'
      | 'docuseal-with-postgres'
      | 'dokuwiki'
      | 'duplicati'
      | 'emby'
      | 'embystat'
      | 'fider'
      | 'filebrowser'
      | 'firefly'
      | 'formbricks'
      | 'ghost'
      | 'gitea'
      | 'gitea-with-mariadb'
      | 'gitea-with-mysql'
      | 'gitea-with-postgresql'
      | 'glance'
      | 'glances'
      | 'glitchtip'
      | 'grafana'
      | 'grafana-with-postgresql'
      | 'grocy'
      | 'heimdall'
      | 'homepage'
      | 'jellyfin'
      | 'kuzzle'
      | 'listmonk'
      | 'logto'
      | 'mediawiki'
      | 'meilisearch'
      | 'metabase'
      | 'metube'
      | 'minio'
      | 'moodle'
      | 'n8n'
      | 'n8n-with-postgresql'
      | 'next-image-transformation'
      | 'nextcloud'
      | 'nocodb'
      | 'odoo'
      | 'openblocks'
      | 'pairdrop'
      | 'penpot'
      | 'phpmyadmin'
      | 'pocketbase'
      | 'posthog'
      | 'reactive-resume'
      | 'rocketchat'
      | 'shlink'
      | 'slash'
      | 'snapdrop'
      | 'statusnook'
      | 'stirling-pdf'
      | 'supabase'
      | 'syncthing'
      | 'tolgee'
      | 'trigger'
      | 'trigger-with-external-database'
      | 'twenty'
      | 'umami'
      | 'unleash-with-postgresql'
      | 'unleash-without-database'
      | 'uptime-kuma'
      | 'vaultwarden'
      | 'vikunja'
      | 'weblate'
      | 'whoogle'
      | 'wordpress-with-mariadb'
      | 'wordpress-with-mysql'
      | 'wordpress-without-database'
    /**
     * Name of the service.
     */
    name?: string
    /**
     * Description of the service.
     */
    description?: string
    /**
     * Project UUID.
     */
    project_uuid: string
    /**
     * Environment name. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_name: string
    /**
     * Environment UUID. You need to provide at least one of environment_name or environment_uuid.
     */
    environment_uuid: string
    /**
     * Server UUID.
     */
    server_uuid: string
    /**
     * Destination UUID. Required if server has multiple destinations.
     */
    destination_uuid?: string
    /**
     * Start the service immediately after creation.
     */
    instant_deploy?: boolean
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw?: string
  }
  path?: never
  query?: never
  url: '/services'
}

export type CreateServiceErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type CreateServiceError = CreateServiceErrors[keyof CreateServiceErrors]

export type CreateServiceResponses = {
  /**
   * Service created successfully.
   */
  201: {
    /**
     * Service UUID.
     */
    uuid?: string
    /**
     * Service domains.
     */
    domains?: Array<string>
  }
}

export type CreateServiceResponse =
  CreateServiceResponses[keyof CreateServiceResponses]

export type DeleteServiceByUuidData = {
  body?: never
  path: {
    /**
     * Service UUID
     */
    uuid: string
  }
  query?: {
    /**
     * Delete configurations.
     */
    delete_configurations?: boolean
    /**
     * Delete volumes.
     */
    delete_volumes?: boolean
    /**
     * Run docker cleanup.
     */
    docker_cleanup?: boolean
    /**
     * Delete connected networks.
     */
    delete_connected_networks?: boolean
  }
  url: '/services/{uuid}'
}

export type DeleteServiceByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteServiceByUuidError =
  DeleteServiceByUuidErrors[keyof DeleteServiceByUuidErrors]

export type DeleteServiceByUuidResponses = {
  /**
   * Delete a service by UUID
   */
  200: {
    message?: string
  }
}

export type DeleteServiceByUuidResponse =
  DeleteServiceByUuidResponses[keyof DeleteServiceByUuidResponses]

export type GetServiceByUuidData = {
  body?: never
  path: {
    /**
     * Service UUID
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}'
}

export type GetServiceByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetServiceByUuidError =
  GetServiceByUuidErrors[keyof GetServiceByUuidErrors]

export type GetServiceByUuidResponses = {
  /**
   * Get a service by UUID.
   */
  200: Service
}

export type GetServiceByUuidResponse =
  GetServiceByUuidResponses[keyof GetServiceByUuidResponses]

export type UpdateServiceByUuidData = {
  /**
   * Service updated.
   */
  body: {
    /**
     * The service name.
     */
    name?: string
    /**
     * The service description.
     */
    description?: string
    /**
     * The project UUID.
     */
    project_uuid: string
    /**
     * The environment name.
     */
    environment_name: string
    /**
     * The environment UUID.
     */
    environment_uuid: string
    /**
     * The server UUID.
     */
    server_uuid: string
    /**
     * The destination UUID.
     */
    destination_uuid?: string
    /**
     * The flag to indicate if the service should be deployed instantly.
     */
    instant_deploy?: boolean
    /**
     * Connect the service to the predefined docker network.
     */
    connect_to_docker_network?: boolean
    /**
     * The Docker Compose raw content.
     */
    docker_compose_raw: string
  }
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}'
}

export type UpdateServiceByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateServiceByUuidError =
  UpdateServiceByUuidErrors[keyof UpdateServiceByUuidErrors]

export type UpdateServiceByUuidResponses = {
  /**
   * Service updated.
   */
  200: {
    /**
     * Service UUID.
     */
    uuid?: string
    /**
     * Service domains.
     */
    domains?: Array<string>
  }
}

export type UpdateServiceByUuidResponse =
  UpdateServiceByUuidResponses[keyof UpdateServiceByUuidResponses]

export type ListEnvsByServiceUuidData = {
  body?: never
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}/envs'
}

export type ListEnvsByServiceUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type ListEnvsByServiceUuidError =
  ListEnvsByServiceUuidErrors[keyof ListEnvsByServiceUuidErrors]

export type ListEnvsByServiceUuidResponses = {
  /**
   * All environment variables by service UUID.
   */
  200: Array<EnvironmentVariable>
}

export type ListEnvsByServiceUuidResponse =
  ListEnvsByServiceUuidResponses[keyof ListEnvsByServiceUuidResponses]

export type UpdateEnvByServiceUuidData = {
  /**
   * Env updated.
   */
  body: {
    /**
     * The key of the environment variable.
     */
    key: string
    /**
     * The value of the environment variable.
     */
    value: string
    /**
     * The flag to indicate if the environment variable is used in preview deployments.
     */
    is_preview?: boolean
    /**
     * The flag to indicate if the environment variable is used in build time.
     */
    is_build_time?: boolean
    /**
     * The flag to indicate if the environment variable is a literal, nothing espaced.
     */
    is_literal?: boolean
    /**
     * The flag to indicate if the environment variable is multiline.
     */
    is_multiline?: boolean
    /**
     * The flag to indicate if the environment variable's value is shown on the UI.
     */
    is_shown_once?: boolean
  }
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}/envs'
}

export type UpdateEnvByServiceUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateEnvByServiceUuidError =
  UpdateEnvByServiceUuidErrors[keyof UpdateEnvByServiceUuidErrors]

export type UpdateEnvByServiceUuidResponses = {
  /**
   * Environment variable updated.
   */
  201: {
    message?: string
  }
}

export type UpdateEnvByServiceUuidResponse =
  UpdateEnvByServiceUuidResponses[keyof UpdateEnvByServiceUuidResponses]

export type CreateEnvByServiceUuidData = {
  /**
   * Env created.
   */
  body: {
    /**
     * The key of the environment variable.
     */
    key?: string
    /**
     * The value of the environment variable.
     */
    value?: string
    /**
     * The flag to indicate if the environment variable is used in preview deployments.
     */
    is_preview?: boolean
    /**
     * The flag to indicate if the environment variable is used in build time.
     */
    is_build_time?: boolean
    /**
     * The flag to indicate if the environment variable is a literal, nothing espaced.
     */
    is_literal?: boolean
    /**
     * The flag to indicate if the environment variable is multiline.
     */
    is_multiline?: boolean
    /**
     * The flag to indicate if the environment variable's value is shown on the UI.
     */
    is_shown_once?: boolean
  }
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}/envs'
}

export type CreateEnvByServiceUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type CreateEnvByServiceUuidError =
  CreateEnvByServiceUuidErrors[keyof CreateEnvByServiceUuidErrors]

export type CreateEnvByServiceUuidResponses = {
  /**
   * Environment variable created.
   */
  201: {
    uuid?: string
  }
}

export type CreateEnvByServiceUuidResponse =
  CreateEnvByServiceUuidResponses[keyof CreateEnvByServiceUuidResponses]

export type UpdateEnvsByServiceUuidData = {
  /**
   * Bulk envs updated.
   */
  body: {
    data: Array<{
      /**
       * The key of the environment variable.
       */
      key?: string
      /**
       * The value of the environment variable.
       */
      value?: string
      /**
       * The flag to indicate if the environment variable is used in preview deployments.
       */
      is_preview?: boolean
      /**
       * The flag to indicate if the environment variable is used in build time.
       */
      is_build_time?: boolean
      /**
       * The flag to indicate if the environment variable is a literal, nothing espaced.
       */
      is_literal?: boolean
      /**
       * The flag to indicate if the environment variable is multiline.
       */
      is_multiline?: boolean
      /**
       * The flag to indicate if the environment variable's value is shown on the UI.
       */
      is_shown_once?: boolean
    }>
  }
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}/envs/bulk'
}

export type UpdateEnvsByServiceUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type UpdateEnvsByServiceUuidError =
  UpdateEnvsByServiceUuidErrors[keyof UpdateEnvsByServiceUuidErrors]

export type UpdateEnvsByServiceUuidResponses = {
  /**
   * Environment variables updated.
   */
  201: {
    message?: string
  }
}

export type UpdateEnvsByServiceUuidResponse =
  UpdateEnvsByServiceUuidResponses[keyof UpdateEnvsByServiceUuidResponses]

export type DeleteEnvByServiceUuidData = {
  body?: never
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
    /**
     * UUID of the environment variable.
     */
    env_uuid: string
  }
  query?: never
  url: '/services/{uuid}/envs/{env_uuid}'
}

export type DeleteEnvByServiceUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type DeleteEnvByServiceUuidError =
  DeleteEnvByServiceUuidErrors[keyof DeleteEnvByServiceUuidErrors]

export type DeleteEnvByServiceUuidResponses = {
  /**
   * Environment variable deleted.
   */
  200: {
    message?: string
  }
}

export type DeleteEnvByServiceUuidResponse =
  DeleteEnvByServiceUuidResponses[keyof DeleteEnvByServiceUuidResponses]

export type StartServiceByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}/start'
}

export type StartServiceByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type StartServiceByUuidError =
  StartServiceByUuidErrors[keyof StartServiceByUuidErrors]

export type StartServiceByUuidResponses = {
  /**
   * Start service.
   */
  200: {
    message?: string
  }
}

export type StartServiceByUuidResponse =
  StartServiceByUuidResponses[keyof StartServiceByUuidResponses]

export type StopServiceByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: never
  url: '/services/{uuid}/stop'
}

export type StopServiceByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type StopServiceByUuidError =
  StopServiceByUuidErrors[keyof StopServiceByUuidErrors]

export type StopServiceByUuidResponses = {
  /**
   * Stop service.
   */
  200: {
    message?: string
  }
}

export type StopServiceByUuidResponse =
  StopServiceByUuidResponses[keyof StopServiceByUuidResponses]

export type RestartServiceByUuidData = {
  body?: never
  path: {
    /**
     * UUID of the service.
     */
    uuid: string
  }
  query?: {
    /**
     * Pull latest images.
     */
    latest?: boolean
  }
  url: '/services/{uuid}/restart'
}

export type RestartServiceByUuidErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type RestartServiceByUuidError =
  RestartServiceByUuidErrors[keyof RestartServiceByUuidErrors]

export type RestartServiceByUuidResponses = {
  /**
   * Restart service.
   */
  200: {
    message?: string
  }
}

export type RestartServiceByUuidResponse =
  RestartServiceByUuidResponses[keyof RestartServiceByUuidResponses]

export type ListTeamsData = {
  body?: never
  path?: never
  query?: never
  url: '/teams'
}

export type ListTeamsErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type ListTeamsError = ListTeamsErrors[keyof ListTeamsErrors]

export type ListTeamsResponses = {
  /**
   * List of teams.
   */
  200: Array<Team>
}

export type ListTeamsResponse = ListTeamsResponses[keyof ListTeamsResponses]

export type GetTeamByIdData = {
  body?: never
  path: {
    /**
     * Team ID
     */
    id: number
  }
  query?: never
  url: '/teams/{id}'
}

export type GetTeamByIdErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetTeamByIdError = GetTeamByIdErrors[keyof GetTeamByIdErrors]

export type GetTeamByIdResponses = {
  /**
   * List of teams.
   */
  200: Team
}

export type GetTeamByIdResponse =
  GetTeamByIdResponses[keyof GetTeamByIdResponses]

export type GetMembersByTeamIdData = {
  body?: never
  path: {
    /**
     * Team ID
     */
    id: number
  }
  query?: never
  url: '/teams/{id}/members'
}

export type GetMembersByTeamIdErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
  /**
   * Resource not found.
   */
  404: {
    message?: string
  }
}

export type GetMembersByTeamIdError =
  GetMembersByTeamIdErrors[keyof GetMembersByTeamIdErrors]

export type GetMembersByTeamIdResponses = {
  /**
   * List of members.
   */
  200: Array<User>
}

export type GetMembersByTeamIdResponse =
  GetMembersByTeamIdResponses[keyof GetMembersByTeamIdResponses]

export type GetCurrentTeamData = {
  body?: never
  path?: never
  query?: never
  url: '/teams/current'
}

export type GetCurrentTeamErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type GetCurrentTeamError =
  GetCurrentTeamErrors[keyof GetCurrentTeamErrors]

export type GetCurrentTeamResponses = {
  /**
   * Current Team.
   */
  200: Team
}

export type GetCurrentTeamResponse =
  GetCurrentTeamResponses[keyof GetCurrentTeamResponses]

export type GetCurrentTeamMembersData = {
  body?: never
  path?: never
  query?: never
  url: '/teams/current/members'
}

export type GetCurrentTeamMembersErrors = {
  /**
   * Invalid token.
   */
  400: {
    message?: string
  }
  /**
   * Unauthenticated.
   */
  401: {
    message?: string
  }
}

export type GetCurrentTeamMembersError =
  GetCurrentTeamMembersErrors[keyof GetCurrentTeamMembersErrors]

export type GetCurrentTeamMembersResponses = {
  /**
   * Currently authenticated team members.
   */
  200: Array<User>
}

export type GetCurrentTeamMembersResponse =
  GetCurrentTeamMembersResponses[keyof GetCurrentTeamMembersResponses]

export type ClientOptions = {
  baseUrl: 'https://app.coolify.io/api/v1' | (string & {})
}
